# 正则表达式

> **参考资料**  
> 资料1：[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)  
> 资料2：[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp)    
> 资料3：[https://deerchao.cn/tutorials/regex/regex.htm](https://deerchao.cn/tutorials/regex/regex.htm)  
> <br />
> **实用工具**  
> - **Learn regex the easy way（**这个仓库教程被翻译成十几种语言了，包含了中文翻译，它通过极其简单的实例，帮助你理解正则基础语法规则**）：**[https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md](https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md)
> - 逐步学习正则（含实战在线练习题）：[https://regexlearn.com/zh-cn](https://regexlearn.com/zh-cn)
> - 正则可视化(边写边能看出匹配的规则内容): 
>    - 在线地址：[https://jex.im/regulex/](https://jex.im/regulex/#!flags=&re=%5E(a%7Cb)*%3F%24)
>    - 仓库地址：[https://github.com/features/copilot/](https://github.com/features/copilot/)

<br />
<br />
&emsp;&emsp;什么是正则表达式，我们可以理解为一种浏览器可以识别的规则，有了这种规则，浏览器就可以帮助我们判断某些字符是否满足符合我们特定场景的业务需求。

为啥我们要去学习正则呢，如果我们熟练的使用正则就会在某些业务场景下，那我们的代码量会明显的减少，而且会更具有可读性。 

举个简单的例子，如何数字进行千分位分隔符呢
```javascript
/** 首先我们得了解业务场景下的规则，比如实现千分位分隔符：
*/
const num = 12345678
// 123，456，78
// 不使用正则
function splitNum(str) {
  if (!str) return false
  const arr1 = str.split('').reverse()
  // 12345678
  // 876,543,21
  // ,123,456,78
  const arr2 = []
  for (let index = 0; index < arr1.length; index++) {
    if (index % 3 === 0 && index !== 0) {
      arr2.push(',')
    }
    arr2.push(arr1[index])
  }
  return arr2.reverse().join('')
}
splitNum(num.toString()) // 12,345,678

// 使用正则
const numReg = /(?!^)(?=(\d{3})+$)/g
num.toString().replace(numReg, ',')

```
上面这个简单的例子可以看出，如果使用正则，代码量明显变少了，而且也更加的直观

那我们如何去学习和使用正则呢：

正则表达式是匹配模式，要么匹配字符，要么匹配位置

字符大家应该都清楚，那位置呢，可以看下图：<br />![image.png](./1697787362465-0.png)

咱们可以将位置理解为相邻字符间的位置

## 一、正则的创建
### 创建方法
在JS中有两种方式创建一个正则表达式<br />（1）通过调用 RegExp 对象的构造函数创建
```javascript
const regExp = new RegExp(正则表达式, 标志);
```
问：<br />正则表达式中如何使用变量？

（2）利用字面量创建正则表达式<br />使用一个正则表达式**字面量**，其由包含在斜杠之间的模式组成。<br />脚本加载后，正则表达式字面量就会被编译。<br />当正则表达式保持不变时，使用此方法可获得**更好的性能**。
```javascript
const reg = /正则表达式/[可选的标志];
```
### 修饰符
**前端小伙伴最熟悉的标签：img**

| i**（**忽略大小写） | 如果u标志也被启用，使用Unicode大小写折叠。 |
| --- | --- |
| m**（多行匹配）** | 更改^和$的含义，使它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下,$的精确含意是:匹配\\n或\\r之前的位置以及字符串结束前的位置.) |
| g （全局匹配） | 找到所有的匹配，而不是在第一个匹配之后停止。 |


## 二、正则表达式中的位置
 **元字符**

| **代码** | **单词** | **说明** |
| --- | --- | --- |
| . | <br /> | 匹配除换行符意外的任意字符 |
| \\w | word | 匹配字母或下划线或汉字 |
| \\s | space | 匹配任意的空白符 |
| \\d | digtal | 匹配数字 |
| \\b | <br /> | 匹配单词的开始或结束 |
| ^ | <br /> | 匹配字符串的开始 |
| $ | <br /> | 匹配字符串的应用 |
| <br /> | <br /> | <br /> |


**反义**

| **代码/语法** | **说明** |
| --- | --- |
| \\W | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \\S | 匹配任意不是空白符的字符 |
| \\D | 匹配任意非数字的字符 |
| \\B | 匹配不是单词开头或结束的位置 |
| [^x] | 匹配除了x以外的任意字符 |
| [^aeiou] | 匹配除了aeiou这几个字母以外的任意字符<br /> |



1、^ 脱字符，用于匹配行的开头
```javascript
const str = 'hello'
str.replace(/^/, '*') 
// '*hello'
```

2、$ 美元符号，匹配行的结尾
```javascript
const str = 'hello'
str.replace(/$/, '*') 
// 'hello*'
```

3、\b 单词的边界<br />\w是字符组[0-9a-zA-Z_]的简写形式，即\w是字母数字或者下划线的中任何一个字符。<br />而\W是排除字符组[^0-9a-zA-Z_]的简写形式，即\W是\w以外的任何一个字符。

单词边界有三大规则：<br />1、^和\w之间的位置<br />2、\w和\W之间的位置<br />3、\w和$之间的位置

可以看图理解<br />![image.png](./1697787362465-1.png)
```javascript
// hello_1.js => *hello_1*.*js*
const str = 'hello_1.js'
str.replace(/\b/g, '*')
```

4、\B非单词的边界，即扣掉\b，剩下的都是\B

5、(?=p) 学名叫做正向先行断言，其中p是子模式，即p前面的那个位置<br />![image.png](./1697787362465-2.png)
```javascript
// hello.js => h*ello.js
const str = 'hello.js'
str.replace(/(?=ell)/g, '*')
```
6、(?!p)学名叫做负向先行断言，可以理解为(?=p)匹配到的位置之外的位置都是属于(?!p)
```javascript
// h*ello.js => '*he*l*l*o*.*j*s*'
const str = 'hello.js'
str.replace(/(?!ell)/g, '*')
```

7、(?<=p)符合p子模式后面的那个位置
```javascript
// hello.js => hell*o.js
const str = 'hello.js'
str.replace(/(?<=ell)/g, '*')
```

8、(?<!p) 其实就是(?<=p)取非集，我们可以这样理解(?<=p)匹配到的位置之外的位置
```javascript
// hell*o.js => *h*e*l*lo*.*j*s*
const str = 'hello.js'
str.replace(/(?<!ell)/g, '*')
```

## 三、正则表达式括号的作用
### () - 小括号：分组

- **分组/子表达式：**使用小括号指定一个子表达式后，**匹配这个子表达式的文本**	(也就是此分组捕获的内容)可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个**组号。<br />例如：**对于匹配连续多次出现单个字符"c"，/c+/，如果要匹配连续出现的"code"时，则使用/(code)+/，其中括号是提供分组功能，量词"+"作用与"code"这个整体
- **规则：**从左往右
- **后向引用**/捕获(身在其中的斜杠青年)：\1、\2、\3
- **分组匹配(**只认结果的美元小组**): **$1、$\2、$3
```javascript
// 后向引用.应用于正则表达式的模式中
/\b(\w+)\b\s+\1\b/.test('go go')

// 分组匹配.应用于正则表达式模式匹配的结果中
var re = /(\w+)\s(\w+)/;
var str = "John Smith";
var newstr = str.replace(re, "$2, $1");
// Smith, John
console.log(newstr);
```
## 
### [] - 中括号: 集合/字符集
用于匹配没有预定义的元字符字符集合(比如元音字母a,e,i,o,u)，例如

- [aeiou]	就匹配	任何一个英文元音字母
- [.?!]	匹配	标点符号(.或?或!)

指定一个字符**范围**

- [0-9]	代表的含意与, \d 就是完全一致的。
- [a-z0-9A-Z_]	也完全等同于, \w（如果只考虑英文的话）
## 
### {} - 大括号: 重复/限定符
| **代码/语法** | **说明** |
| --- | --- |
| * | 重复零次或更多次 |
| + | 重复一次或更多次 |
| ? | 重复零次或一次 |
| \{n\} | 重复n次 |
| \{n,\} | 重复n次或更多次 |
| \{n,m\} | 重复n到m次 |

**口诀：“星加问，零一零一”**

**下面是一些使用重复的例子：**<br />Windows\d+匹配Windows后面跟1个或更多数字<br />^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体匹配哪个意思得看选项设置)

## 四、贪婪与懒惰
	当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配**尽可能多**的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索_aabab_的话，它会匹配整个字符串aabab。这被称为**贪婪**匹配。<br />	有时，我们更需要**懒惰**匹配，也就是匹配**尽可能少**的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：<br />	a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于_aabab_的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。

| 代码/语法 | 说明 |
| --- | --- |
| *? | 重复任意次，但尽可能少重复 |
| +? | 重复1次或更多次，但尽可能少重复 |
| ?? | 重复0次或1次，但尽可能少重复 |
| {n,m}? | 重复n到m次，但尽可能少重复 |
| {n,}? | 重复n次以上，但尽可能少重复<br /> |


## 五、分枝条件 

- 正则表达式里的	**分枝条件**	指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用	|	把不同的规则分隔开
- **使用分枝条件时，要注意各个条件的顺序**
- 匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了
```javascript
// 这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)。
/0\d{2}-\d{8}|0\d{3}-\d{7}/.test('010-12345678')

// 这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用分枝条件把这个表达式扩展成也支持4位区号的。
/\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}/.test('029-12345678')

// 这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用分枝条件时，要注意各个条件的顺序。
/\d{5}-\d{4}|\d{5}/.test('12345-6789')

// 如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。

```


## 六、正则表达式常用方法
正则表达式是用于匹配字符串中字符组合的模式。<br />在 JavaScript中，**正则表达式也是对象**。<br />这些模式被用于 RegExp 的 exec 和 test 方法, <br />以及 String 的 match、matchAll、replace、search 和 split 方法
### 1、replace
替换字符串，用来替换的参数可以是一个字符串或者一个正则表达式
```javascript
str.replace(regexp/substr,replacement)
```
第一个参数：被替换的字符串 或者 正则表达式<br />第二个参数：替换为的字符串<br />返回值是一个替换完毕的新字符串。 

### 2、test
检索字符串，检索正则表达式与指定的字符串是否匹配
```javascript
regexObj.test(str)
```
返回true或者false

### 3、match
检索返回一个字符串匹配正则表达式的结果。
```javascript
str.match(regexp)

const str = '2021-12-01'
const reg1 = /(\d{4})-(\d{2})-(\d{2})/g

str.match(reg1)
// ['2021-12-01']

const reg2 = /(\d{4})-(\d{2})-(\d{2})/
str.match(reg2)
// ['2021-12-01', '2021', '12', '01', index: 0, input: '2021-12-01',  groups: undefined]
```
返回值：<br />如果使用“g”标志，则将返回与完整正则表达式匹配的所有结果，但不返回捕获组 <br />如果未使用“g”标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 在这种情况下，返回的项目将具有如下所述的其他属性。 <br />（1）第0个元素是匹配结果。<br />（2）第1个元素是第一个引用型分组匹配的子字符串。 <br />（3）第2个元素存放的是第二个引用型分组匹配的子字符串，依次类推。

   - group：一个捕获组数组或undefined
   - index：匹配的结果的开始位置
   - input：搜索的字符串
### 4、search
执行正则表达式和字符串的搜索匹配
```javascript
str.search(regexp)
```
如果匹配成功，则search()返回正则表达式在字符串中首次匹配项的索引；否则，返回-1。

## 七、正则表达式的拆分
正则表达式就像一个个火星文一样，单个的还比较容易理解，一大段那种简直就是折磨，因此如何正确的把一大串火星文拆分成小粒度，就成为了关键，如何拆分呢

1、结构和操作符<br />结构：<br />字面量：匹配一个具体字符，包括转义或者非转义的，如匹配字符’c‘, \n换行符，\.小数点等等<br />字符组：匹配一个一个字符，可以是多种可能之一，如[a-z]、[123]等等<br />量词：表示连续的出现{m,n}<br />锚点：匹配一个位置，而非上述的字符；如：^以啥开头，(?=code)，code前面的位置<br />分支：多个子表示多选一；如：code1|code2<br />分组：用括号表示一个整体；如：(code)+，表示’code‘字符连续出现多次<br />反向引用：如\2、\3等，表示引用第2、第3个分组

操作符：<br />1、转义符\<br />2、括号和方括号，(....)、[...]<br />3、量词限定符，{m,n}、 ? 、*、+<br />4、位置和序列，^、$、\元字符、一般字符<br />5、管道符，|<br />ps：上述操作符优先级由高到低

来个栗子：<br />/ab*(c|de?)+|fg/<br />1、因为括号的原因，(c|de?)是一个整体<br />2、在括号的内容里边"de?"中的“?”，所以e是一个整体<br />3、括号中有“|”，所以“c”是一个整体，“de?”又是一个整体<br />4、以此类推，整个正则分为：a、b*、(.....)+、f、g；除此之外，由于分支“|”的原因，也可以拆为ab*(c|de?)和fg这两个部分<br />![image.png](./1697787362465-3.png)

## 八、正则表达式的构建
前提：<br />1、能否使用正则<br />如匹配类似'ababbabbbabbbb......'这样的字符，看起来有规律，但是咱没法用正则来解决

2、有没有必要使用正则<br />如果咱们能使用API能解决问题，就没必要使用正则<br />比如在日期里面提取年月日
```javascript
const str = '2021-12-01'
const reg2 = /(\d{4})-(\d{2})-(\d{2})/
str.match(reg2)
// ['2021-12-01', '2021', '12', '01', index: 0, input: '2021-12-01',  groups: undefined]

//不使用正则
const res = str.split('-')
// ['2021', '12', '01']

```

构建：<br />如何构建一个正则呢，我们需要先了解目标的组成规则，明确规则之后，再把这些规则按位置拆分，拆分成一个个的子模块，最后将这些子模块组合起来；

来个简单的栗子：<br />匹配固定电话，有以下格式：<br />1、085912345678<br />2、0859-12345678<br />3、(0859)12345678

分析：<br />1、首先了解各个格式的组成规则<br />分为区号和号码部分，区号由0加上3位数字组成，号码由非0的一位数字加上7位任意数字组成<br />区号：/0\d{3}/<br />号码：/[1-9]\d{7}/<br />因此第一个格式的正则为：/^0\d{3}[1-9]\d{7}$/<br />第二个的格式为：/^0\d{3}-[1-9]\d{7}$/<br />第三个的格式为：/^\(0\d{3}\)[1-9]\d{7}$/<br />所以最终的正则为：/^(0\d{3}|0\d{3}-|\(0\d{3}\)[1-9]\d{7})$/<br />/^(|0\d{3}-?|\(0\d{3}\)[1-9]\d{7})$/


# 九、常见正则表达式收集
[https://mp.weixin.qq.com/s/aF-D3Qr23QxNP8kMZrI0QQ](https://mp.weixin.qq.com/s/aF-D3Qr23QxNP8kMZrI0QQ)

# 十、正则表达式-学习工具
从零基础到高阶-通过X步骤，X道题：[https://regexlearn.com/zh-cn](https://regexlearn.com/zh-cn)
